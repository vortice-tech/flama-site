---
title: Packaging models
wip: false
---

## Introduction

Any machine-learning model built using one of the mainstream data-science frameworks, e.g.
[Scikit-Learn](https://scikit-learn.org/stable/), [TensorFlow](https://www.tensorflow.org/) or
[PyTorch](https://pytorch.org/), can be served using <FlamaName/>. This, indeed, is what we have been explaining in the
previous sections on <FlamaName/> CLI commands [run](/docs/flama-cli/run), [serve](/docs/flama-cli/serve), and
[start](/docs/flama-cli/start). For this to happen, we needed either of the following two options:

- A model packaged as a binary file (**.flm** files)
- A model embedded in a <FlamaName/> App

The second option will be explained in detail in the following sections:
[add models](/docs/machine-learning-api/add-models), [model resource](/docs/machine-learning-api/model-resource), and
[model components](/docs/machine-learning-api/model-components). The first option (which is the one we are going to
discuss in what follows) requires us to save the models following a certain procedure. For the sake of convenience and
speeding up the process of integrating these models into an API, <FlamaName /> comes with the functionality required to
serialise and package them, automatically adding important metadata which make the resulting files operational.

## FLM files

The binary files needed by the <FlamaName/> CLI are typically named with the suffix **.flm**. We call them _flama_ files
for the sake of simplicity, but FLM stands for **Flama Lightweight Model**. This comes from the fact that, FLM files are
a lightweight representation of ML models, which come with useful metadata needed for later purposes, e.g. building a
wrapper <FlamaName/> app containing the model.

## Dump & load

Let's consider the following familiar situation, which is the day-to-day routine of many data scientists. After careful
experimentation, cross-validation, testing, and so on, we have found the optimal ML model for our problem. Great job!
Now, we want to take our model out of our Jupyter Notebook, and offer it as a service to make predictions on demand. The
first thing we think about is [pickling](https://docs.python.org/3/library/pickle.html#module-pickle) (i.e., using
**pickle.dump**) the model, and pass the resulting file to the corresponding team/colleague to develop the wrapper API
which will have to eventually _unpickle_ (i.e., using **pickle.load**) the object, and expose the **predict** method. It
seems like a very repetitive and boring task, doesn't it?

As we have seen already when we introduced [serve](/docs/flama-cli/serve) and [start](/docs/flama-cli/start),
<FlamaName /> comes equipped with a very convenient CLI which does all the boring part for you seamlessly, just with a
single line of code. For this, we only need our models to be packaged with the <FlamaName /> counterparts of pickle's
dump and load commands, namely: **flama.dump** and **flama.load**.

### Dump method

<FlamaName /> **dump** method uses optimal compression with the aim of making the packing process more efficient, and
faster. The packing step can live completely out of any <FlamaName /> application. Indeed, the natural place to package
your models will be at the model-building stage, which will be very likely happening on your Jupyter notebook. An
example of usage of this method:

```python
import flama

with open("path/to/file.flm", "wb") as fs:
    flama.dump(
        lib=flama.ModelFormat.pytorch, # library the model is built with
        model=model,                   # the model object itsel
        fs=fs,                         # BinaryIO where the model will be stored
    )
```

### Load method

<FlamaName /> **load** method is responsible for the efficient unpacking of the model file. The *unpacking* stage will
typically happen within the context of a <FlamaName /> application. If you're not planning the development of any
because you'll be using <FlamaName /> CLI for this, then you won't have to use the load methods at all. An example of
usage of this method:

```python
import flama

with open("path/to/file.flm", "rb") as fs:
    flama.load(
        lib=flama.ModelFormat.pytorch, # library the model is built with
        model=model,                   # the model object itsel
        fs=fs,                         # BinaryIO where the model is stored
    )
```

Having introduced the methods which allow for packing (**flama.dump**) and loading (**flama.load**), we can proceed and
introduce how the example files we've been using so far were generated. These files were:

- [Scikit Learn model](/models/sklearn_model.flm)
- [TensorFlow model](/models/tensorflow_model.flm)
- [PyTorch model](/models/pytorch_model.flm)

## Examples

Let's proceed showing how to pack scikit-learn, tensorflow, and pytorch models, respectively. The following examples
don't intend to be complete nor functional pieces of code. The examples aim at showing the relevant steps for the
purpose of packagin models, so they do not include the following natural stages: data loading and cleansing, training
and testing.

### Scikit-Learn

```python
import flama
from sklearn.linear_model import LogisticRegression

model = LogisticRegression()
model.fit(x_train, y_train)

with open("sk_model.flm", "wb") as f:
    flama.dump("sklearn", model, f)
```

### TensorFlow

```python
import flama
import tensorflow as tf

model = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10, activation='softmax')
])
model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)
model.fit(x_train, y_train, epochs=5)

with open("tf_model.flm", "wb") as f:
    flama.dump("tensorflow", model, f)
```

### PyTorch

```python
import flama
import torch

class Model(torch.nn.Module):
    def forward(self, x):
        return x + 10

with open("torch_model.flm", "wb") as f:
    flama.dump("pytorch", model, f)
```
